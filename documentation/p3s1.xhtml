<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>io7m-jfprop 0.3.0 Documentation: 3.1. Type Rules</title><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-layout.css"/><link rel="stylesheet" type="text/css" href="jstructural-2.0.0-colour.css"/><link rel="stylesheet" type="text/css" href="documentation.css"/></head><body><div class="st200_body"><div class="brand">
  <div class="brand_left">
    <a href="http://io7m.com/">io7m</a>
  </div>
  <div class="brand_right">
    <a href="http://io7m.github.io/jfprop">io7m-jfprop</a> 0.3.0
  </div>
</div><div class="st200_navbar st200_navbar_top"><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_title_cell">3. API Reference: Types</td><td class="st200_navbar_up_title_cell">3. API Reference: Types</td><td class="st200_navbar_next_title_cell">3.2. Functions</td></tr><tr><td class="st200_navbar_prev_file_cell"><a href="p3.xhtml#st200_p3">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p3.xhtml#st200_p3">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p3s2.xhtml#st200_p3s2">Next</a></td></tr></table><hr class="st200_hr"/></div><div class="st200_section_container"><div class="st200_section_title_number"><a id="st200_p3s1" href="#st200_p3s1">3.1</a></div><div class="st200_section_title">Type Rules</div><ul class="st200_contents st200_section_contents_outer st200_section_contents"><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="p3s1.xhtml#st200_p3s1ss1">3.1.1. Overview</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="p3s1.xhtml#st200_p3s1ss2">3.1.2. Typing Rules</a></li><li class="st200_contents_item st200_contents_item1 st200_contents_item_subsection"><a href="p3s1.xhtml#st200_p3s1ss3">3.1.3. Predefined Types</a></li></ul><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss1" href="#st200_p3s1ss1">3.1.1</a></div><div class="st200_subsection_title">Overview</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss1pg1" href="#st200_p3s1ss1pg1">1</a></div><div class="st200_paragraph">
        The APIs exposed by the servers accept parameters that are each
        implicitly of a given <span class="st200_term term">type</span>. Because
        HTTP only exposes an interface that only allows parameters to be
        arbitrary character strings, it's necessary to give 
        <span class="st200_term term">interpretive</span> typing rules. That is,
        the rules state that a given string <span class="st200_term variable">s</span>
        is of type <span class="st200_term type">t</span> iff 
        <span class="st200_term variable">s</span> 
        <span class="st200_term term">can be interpreted as</span> a value of
        type <span class="st200_term type">t</span> according to the given set of
        rules for <span class="st200_term type">t</span>.
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss1pg2" href="#st200_p3s1ss1pg2">2</a></div><div class="st200_paragraph">
        As an example, a string <span class="st200_term variable">s</span> 
        can be interpreted as a value of type <span class="st200_term type">integer</span>
        iff the contents of the string match the pattern
        <span class="st200_term expression">0 | [1-9][0-9]*</span>.
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss1pg3" href="#st200_p3s1ss1pg3">3</a></div><div class="st200_paragraph">
        The purpose of giving typing rules in this style is so that APIs
        can be defined in terms of the types of the parameters, and a programmer
        reading the API definition need only look up the definitions of the types
        to know how to correctly format string values for the API. Additionally,
        developers may be speaking to the server from any number of different
        programming languages. The rules are given in terms of an extremely
        simple pure-functional language and so are easily mapped
        to code written in more or less any modern programming language.
      </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss2" href="#st200_p3s1ss2">3.1.2</a></div><div class="st200_subsection_title">Typing Rules</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss2pg1" href="#st200_p3s1ss2pg1">1</a></div><div class="st200_paragraph">
        Rules are specified in terms of combinations of 
        <a class="st200_link" href="p3s2.xhtml#st200_p3s2">functions</a>
        over <span class="st200_term type">string</span>,
        <span class="st200_term type">character</span>,
        <span class="st200_term type">integer</span>, and 
        <span class="st200_term type">boolean</span> types.
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss2pg2" href="#st200_p3s1ss2pg2">2</a></div><div class="st200_paragraph">
        The syntax <span class="st200_term expression">s : t</span>
        means that <span class="st200_term variable">s</span> is of
        type <span class="st200_term variable">t</span>. The syntax
        <span class="st200_term expression">f : t → u</span> states
        that <span class="st200_term variable">f</span> is a function
        that takes a value of type <span class="st200_term variable">t</span>
        and returns a value of type <span class="st200_term variable">u</span>.
        The syntax <span class="st200_term expression">f : (t,u) → v</span>
        states that <span class="st200_term variable">f</span> is
        a function that takes two arguments, the first of type
        <span class="st200_term variable">t</span> and the second of
        type <span class="st200_term variable">u</span> and returns
        a value of type <span class="st200_term variable">v</span>.
        The syntax <span class="st200_term expression">f(x)</span> is
        the application of a unary function
        <span class="st200_term expression">f</span> to a value
        <span class="st200_term expression">x</span>. The syntax
        <span class="st200_term expression">f(x,y)</span> is the application
        of a two-argument function <span class="st200_term expression">f</span>
        to values <span class="st200_term expression">x</span> and
        <span class="st200_term expression">y</span>.
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss2pg3" href="#st200_p3s1ss2pg3">3</a></div><div class="st200_paragraph">
        The syntax <span class="st200_term expression">∀i. p(i)</span>
        introduces a new universally-quantified variable 
        <span class="st200_term variable">i</span> and states that
        the function <span class="st200_term variable">p</span> 
        evaluates to <span class="st200_term constant">true</span>
        for <span class="st200_term variable">i</span>. In other words,
        "for every possible <span class="st200_term variable">i</span>,
        <span class="st200_term variable">p</span> holds for
        <span class="st200_term variable">i</span>".
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss2pg4" href="#st200_p3s1ss2pg4">4</a></div><div class="st200_paragraph">
        The syntax <span class="st200_term expression">∃i. p(i)</span>
        introduces a new existentially-quantified variable 
        <span class="st200_term variable">i</span> and states that
        the function <span class="st200_term variable">p</span>
        evaluates to <span class="st200_term constant">true</span>
        for <span class="st200_term variable">i</span>. In other words,
        "there exists some <span class="st200_term variable">i</span>,
        such that <span class="st200_term variable">p</span> holds for
        <span class="st200_term variable">i</span>".
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss2pg5" href="#st200_p3s1ss2pg5">5</a></div><div class="st200_paragraph">
        The expression <span class="st200_term expression">x ∧ y</span>
        evaluates to <span class="st200_term constant">true</span>
        if both <span class="st200_term variable">x</span> and
        <span class="st200_term variable">y</span> evaluate to 
        <span class="st200_term constant">true</span>. If
        <span class="st200_term variable">x</span> evaluates to
        <span class="st200_term constant">false</span>, then
        <span class="st200_term variable">y</span> is not evaluated
        and the whole expression evaluates to
        <span class="st200_term constant">false</span>. This is the
        same <span class="st200_term term">short-circuit</span> logic
        seen in the <span class="st200_term function">AND</span>
        operators of most programming languages. The 
        <span class="st200_term expression">∧</span> operator is left-associative,
        so <span class="st200_term expression">x ∧ y ∧ z = (x ∧ y) ∧ z</span>.
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss2pg6" href="#st200_p3s1ss2pg6">6</a></div><div class="st200_paragraph">
        The expression <span class="st200_term expression">x ∨ y</span>
        evaluates to <span class="st200_term constant">true</span>
        if either of <span class="st200_term variable">x</span> or
        <span class="st200_term variable">y</span> evaluates to 
        <span class="st200_term constant">true</span>. The 
        <span class="st200_term expression">∧</span> operator is left-associative,
        so <span class="st200_term expression">x ∨ y ∨ z = (x ∨ y) ∨ z</span>.
      </div></div></div><div class="st200_subsection_container"><div class="st200_subsection_title_number"><a id="st200_p3s1ss3" href="#st200_p3s1ss3">3.1.3</a></div><div class="st200_subsection_title">Predefined Types</div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss3pg1" href="#st200_p3s1ss3pg1">1</a></div><div class="st200_paragraph">
        The predefined <span class="st200_term type">boolean</span>
        type has two values: <span class="st200_term constant">true</span>
        and <span class="st200_term constant">false</span>.
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss3pg2" href="#st200_p3s1ss3pg2">2</a></div><div class="st200_paragraph">
        The predefined <span class="st200_term type">integer</span>
        type represents integer values in the exclusive range
        <span class="st200_term type">(-∞, ∞)</span>.
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss3pg3" href="#st200_p3s1ss3pg3">3</a></div><div class="st200_paragraph">
        The predefined <span class="st200_term type">character</span>
        type represents a Unicode codepoint. Specific character
        values are given in type rules by the syntax 
        <span class="st200_term expression">U+NNNN</span>,
        where <span class="st200_term variable">N</span> represents a hexadecimal
        digit. For example, <span class="st200_term constant">U+03BB</span>
        corresponds to the lowercase lambda symbol 
        <span class="st200_term constant">λ</span>. 
        Characters are placed into categories according to the
        Unicode standard, For example, the character
        <span class="st200_term constant">U+0037</span>, corresponding
        to the digit 7 is in the <span class="st200_term constant">DECIMAL_DIGIT_NUMBER</span>
        category.
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss3pg4" href="#st200_p3s1ss3pg4">4</a></div><div class="st200_paragraph">
        The predefined <span class="st200_term type">list[t]</span>
        type represents a bounded list of values of type 
        <span class="st200_term type">t</span>.
      </div></div><div class="st200_paragraph_container"><div class="st200_paragraph_number"><a id="st200_p3s1ss3pg5" href="#st200_p3s1ss3pg5">5</a></div><div class="st200_paragraph">
        The predefined <span class="st200_term type">string</span>
        is a synonym for the type 
        <span class="st200_term type">list[character]</span>.
      </div></div></div></div><div class="st200_navbar st200_navbar_bottom"><hr class="st200_hr"/><table class="st200_navbar_table" summary="Navigation bar"><tr><td class="st200_navbar_prev_file_cell"><a href="p3.xhtml#st200_p3">Previous</a></td><td class="st200_navbar_up_file_cell"><a href="p3.xhtml#st200_p3">Up</a></td><td class="st200_navbar_next_file_cell"><a href="p3s2.xhtml#st200_p3s2">Next</a></td></tr><tr><td class="st200_navbar_prev_title_cell">3. API Reference: Types</td><td class="st200_navbar_up_title_cell">3. API Reference: Types</td><td class="st200_navbar_next_title_cell">3.2. Functions</td></tr></table></div></div></body></html>
